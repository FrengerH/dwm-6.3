--- dwm.c
+++ dwm.c
@@ -124,8 +123,9 @@ struct Monitor {
 	unsigned int tagset[2];
 	int showbar;
 	int topbar;
-	Clientlist *cl;
+	Client *clients;
 	Client *sel;
+	Client *stack;
 	Monitor *next;
 	Window barwin;
 	const Layout *lt[2];
@@ -140,18 +140,12 @@ typedef struct {
 	int monitor;
 } Rule;
 
-struct Clientlist {
-	Client *clients;
-	Client *stack;
-};
-
 /* function declarations */
 static void applyrules(Client *c);
 static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
 static void arrange(Monitor *m);
 static void arrangemon(Monitor *m);
 static void attach(Client *c);
-static void attachclients(Monitor *m);
 static void attachstack(Client *c);
 static void buttonpress(XEvent *e);
 static void checkotherwm(void);
@@ -273,7 +267,6 @@ static Display *dpy;
 static Drw *drw;
 static Monitor *mons, *selmon;
 static Window root, wmcheckwin;
-static Clientlist *cl;
 
 /* configuration, allows nested code to access above variables */
 #include "config.h"
@@ -306,7 +299,7 @@ applyrules(Client *c)
 		{
 			c->isfloating = r->isfloating;
 			c->tags |= r->tags;
-			for (m = mons; m && (m->tagset[m->seltags] & c->tags) == 0; m = m->next);
+			for (m = mons; m && m->num != r->monitor; m = m->next);
 			if (m)
 				c->mon = m;
 		}
@@ -409,49 +402,15 @@ arrangemon(Monitor *m)
 void
 attach(Client *c)
 {
-	c->next = c->mon->cl->clients;
-	c->mon->cl->clients = c;
-}
-
-void
-attachclients(Monitor *m) {
-	/* attach clients to the specified monitor */
-	Monitor *tm;
-	Client *c;
-	unsigned int utags = 0;
-	Bool rmons = False;
-	if(!m)
-		return;
-
-	/* collect information about the tags in use */
-	for (tm = mons; tm; tm = tm->next)
-		if(tm != m)
-			utags |= tm->tagset[tm->seltags];
-
-	for (c = m->cl->clients; c; c = c->next)
-		if(ISVISIBLE(c, m)) {
-			/* if client is also visible on other tags that are displayed on
-			 * other monitors, remove these tags */
-			if(c->tags & utags) {
-				c->tags = c->tags & m->tagset[m->seltags];
-				rmons = True;
-			}
-			unfocus(c, True);
-			c->mon = m;
-		}
-
-	if (rmons)
-		for (tm = mons; tm; tm = tm->next)
-			if(tm != m)
-				arrange(tm);
-
+	c->next = c->mon->clients;
+	c->mon->clients = c;
 }
 
 void
 attachstack(Client *c)
 {
-	c->snext = c->mon->cl->stack;
-	c->mon->cl->stack = c;
+	c->snext = c->mon->stack;
+	c->mon->stack = c;
 }
 
 void
@@ -671,31 +630,10 @@ configurerequest(XEvent *e)
 Monitor *
 createmon(void)
 {
-	Monitor *m, *tm;
-	int i;
+	Monitor *m;
 
-	/* bail out if the number of monitors exceeds the number of tags */
-	for (i=1, tm=mons; tm; i++, tm=tm->next);
-	if (i > LENGTH(tags)) {
-		fprintf(stderr, "dwm: failed to add monitor, number of tags exceeded\n");
-		return NULL;
-	}
-	/* find the first tag that isn't in use */
-	for (i=0; i < LENGTH(tags); i++) {
-		for (tm=mons; tm && !(tm->tagset[tm->seltags] & (1<<i)); tm=tm->next);
-		if (!tm)
-			break;
-	}
-	/* reassign all tags to monitors since there's currently no free tag for the
-	 * new monitor */
-	if (i >= LENGTH(tags))
-		for (i=0, tm=mons; tm; tm=tm->next, i++) {
-			tm->seltags ^= 1;
-			tm->tagset[tm->seltags] = (1<<i) & TAGMASK;
-		}
 	m = ecalloc(1, sizeof(Monitor));
-	m->cl = cl;
-	m->tagset[0] = m->tagset[1] = (1<<i) & TAGMASK;
+	m->tagset[0] = m->tagset[1] = 1;
 	m->mfact = mfact;
 	m->nmaster = nmaster;
 	m->showbar = showbar;
@@ -1475,9 +1413,11 @@ sendmon(Client *c, Monitor *m)
 	if (c->mon == m)
 		return;
 	unfocus(c, 1);
+	detach(c);
 	detachstack(c);
 	c->mon = m;
 	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+	attach(c);
 	attachstack(c);
 	focus(NULL);
 	arrange(NULL);
@@ -1675,7 +1613,7 @@ showhide(Client *c)
 {
 	if (!c)
 		return;
-	if (ISVISIBLE(c, c->mon)) {
+	if (ISVISIBLE(c)) {
 		/* show clients top down */
 		XMoveWindow(dpy, c->win, c->x, c->y);
 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
@@ -1799,27 +1716,12 @@ toggletag(const Arg *arg)
 void
 toggleview(const Arg *arg)
 {
-	Monitor *m;
 	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
 
 	if (newtagset) {
-		/* prevent displaying the same tags on multiple monitors */
-		for(m = mons; m; m = m->next)
-			if(m != selmon && newtagset & m->tagset[m->seltags])
-				return;
 		selmon->tagset[selmon->seltags] = newtagset;
-		attachclients(selmon);
+		focus(NULL);
 		arrange(selmon);
-		focus(NULL);
-
-		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
-
-		if (newtagset) {
-			selmon->tagset[selmon->seltags] = newtagset;
-			attachclients(selmon);
-			arrange(selmon);
-			focus(NULL);
-		}
 	}
 }
 
@@ -1969,13 +1869,16 @@ updategeom(void)
 		} else { /* less monitors available nn < n */
 			for (i = nn; i < n; i++) {
 				for (m = mons; m && m->next; m = m->next);
+				while ((c = m->clients)) {
+					dirty = 1;
+					m->clients = c->next;
+					detachstack(c);
+					c->mon = mons;
+					attach(c);
+					attachstack(c);
+				}
 				if (m == selmon)
 					selmon = mons;
-				for (c = m->cl->clients; c; c = c->next) {
-					dirty = True;
-					if (c->mon == m)
-						c->mon = selmon;
-				}
 				cleanupmon(m);
 			}
 		}
@@ -2109,32 +2012,13 @@ updatewmhints(Client *c)
 void
 view(const Arg *arg)
 {
-	Monitor *m;
-	unsigned int newtagset = selmon->tagset[selmon->seltags ^ 1];
 	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
 		return;
-	/* swap tags when trying to display a tag from another monitor */
-	if (arg->ui & TAGMASK)
-		newtagset = arg->ui & TAGMASK;
-	for (m = mons; m; m = m->next)
-		if (m != selmon && newtagset & m->tagset[m->seltags]) {
-			/* prevent displaying all tags (MODKEY-0) when multiple monitors
-			 * are connected */
-			if (newtagset & selmon->tagset[selmon->seltags])
-				return;
-			m->sel = selmon->sel;
-			m->seltags ^= 1;
-			m->tagset[m->seltags] = selmon->tagset[selmon->seltags];
-			attachclients(m);
-			arrange(m);
-			break;
-		}
 	selmon->seltags ^= 1; /* toggle sel tagset */
 	if (arg->ui & TAGMASK)
 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
-	attachclients(selmon);
+	focus(NULL);
 	arrange(selmon);
-	focus(NULL);
 }
 
 Client *
